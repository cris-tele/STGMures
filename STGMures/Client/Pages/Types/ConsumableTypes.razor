@page "/ConsumableTypes"

@inject IConsumableTypeService consumableService
@inject IConsumableCategoryService categoryService

@inject MudBlazor.ISnackbar snackBar
@inject ISetAppMenuInfos AppMenu


<!--edit card-->
<MudCard Elevation="5">
    <MudCardContent >
        <MudGrid>
            <MudItem xs="3" >    <!-- Se pune Disabled doar in timpul AddEditDelete-->
                <MudSelect ValueChanged="@( id => CategorySelected(id) )"
                    T="int" AnchorOrigin="Origin.BottomCenter" Variant="Variant.Text" Margin="Margin.None" Dense="true">
                    <MudSelectItem Value="0" Disabled="true">Selectati grupa/categoria:</MudSelectItem>
                    @foreach (ConsumableCategory _option in categories)
                    {
                        <MudSelectItem Value="@_option.Id">@_option.Name</MudSelectItem>
                    }
                </MudSelect>
            </MudItem >
        </MudGrid>


        <MudGrid>
            <MudItem xs="1">
                <MudTextField Class="invisible" Disabled="true" @bind-Value="consumable.Id" HelperText="ID" Variant="Variant.Text" Margin="Margin.None"></MudTextField>
            </MudItem>
            <MudItem xs="5">
                <MudTextField Disabled="@_enabledOrDisabled" @bind-Value="consumable.Name" HelperText="Denumire tip consumabil " Variant="Variant.Text" Margin="Margin.None"></MudTextField>
            </MudItem>
            <MudItem xs="2">
                <MudSelect Disabled="@_enabledOrDisabled" T="string" AnchorOrigin="Origin.BottomCenter" @bind-Value="consumable.Type" HelperText="Material" Variant="Variant.Text" Margin="Margin.None">
                    @foreach (var _option in StaticParam.ConsumableType)
                    {
                        <MudSelectItem Value="@_option" />
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="2">
                <MudSelect Disabled="@_enabledOrDisabled" T="string" AnchorOrigin="Origin.BottomCenter" @bind-Value="consumable.Design" HelperText="Design" Variant="Variant.Text" Margin="Margin.None">
                    @foreach (var _option in StaticParam.ConsumableDesign)
                    {
                        <MudSelectItem Value="@_option" />
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="1">
                <MudSelect Disabled="@_enabledOrDisabled" T="string" AnchorOrigin="Origin.BottomCenter" @bind-Value="consumable.ValueFormat" HelperText="Valori de tip" Variant="Variant.Text" Margin="Margin.None">
                    @foreach (var _option in StaticParam.FieldFormat)
                    {
                        <MudSelectItem Value="@_option" />
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="1">
                <MudSelect Disabled="@_enabledOrDisabled" T="string" AnchorOrigin="Origin.BottomCenter" @bind-Value="consumable.MeasureUnit" HelperText="Unitate masura" Variant="Variant.Text" Margin="Margin.None">
                    @foreach (var _option in StaticParam.ConsumableMeasureUnits)
                    {
                        <MudSelectItem Value="@_option" />
                    }
                </MudSelect>
            </MudItem>
        </MudGrid>
    </MudCardContent>

    <MudDivider DividerType="DividerType.FullWidth" Class="border-3 border-solid mud-border-primary" />

    <MudCardActions>
        <AddUpdateDelete @ref="crudObj" OnValidate="@ValidateAction" ItemsCount="@GetTableItems()" @bind-CRUDStatus=_enabledOrDisabled />
    </MudCardActions>
</MudCard>
<br />


<!--table list-->
<MudTable @ref="@_table" Hover="true" Dense="true" Striped="true" Elevation="5"
          Items="@filteredConsumables" Filter="new Func<Consumable, bool>(Search)" @bind-customer="consumable" OnRowClick="@RowClicked" T="Consumable">
    <ToolBarContent>
        <MudSpacer />
        <MudTextField @bind-Value="searchString" Placeholder="Cautati un tip de consumabil..." Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Small" Class="mt-0"></MudTextField>
    </ToolBarContent>
<!--
    <HeaderContent>
        <MudTh Class="invisible xs=1">ID</MudTh>
        <MudTh Class="col-5">Denumire Tip Consumabil</MudTh>
        <MudTh Class="col-2">Material</MudTh>
        <MudTh Class="col-2">Design</MudTh>
        <MudTh Class="col-1">Valori de tip</MudTh>
        <MudTh Class="col-1">Unitate masura</MudTh>
    </HeaderContent>
-->

    <RowTemplate>
        <MudTd Class="invisible xs=1" DataLabel="Id">@context.Id</MudTd>
        <MudTd Class="col-5" DataLabel="Tip">@context.Name</MudTd>
        <MudTd Class="col-2" DataLabel="Tip">@context.Type</MudTd>
        <MudTd Class="col-2" DataLabel="Tip">@context.Design</MudTd>
        <MudTd Class="col-1" DataLabel="Tip">@context.ValueFormat</MudTd>
        <MudTd Class="col-1" DataLabel="Unitate Masura">@context.MeasureUnit</MudTd>
    </RowTemplate>
    <PagerContent>
        <MudTablePager RowsPerPageString="Randuri pagina:" PageSizeOptions="@(new int[] { 5, 10, 25, 50 , int.MaxValue})"> R</MudTablePager>
    </PagerContent>

</MudTable>




@code {
    private bool _enabledOrDisabled = false;
    private AddUpdateDelete? crudObj;

    // table design
    private MudTable<Consumable>? _table;


    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            _table!.SetRowsPerPage(10);
        return base.OnAfterRenderAsync(firstRender);
    }


    // data
    private List<ConsumableCategory> categories = new List<ConsumableCategory>();
    private ConsumableCategory      selectedCategory = new();

    private List<Consumable> consumables = new ();          
    private List<Consumable> filteredConsumables = new(); // filtered by diagnosticCategory

    private Consumable consumable = new();

    private void CategorySelected(int id)   // mudselect category
    {
        if (id != 0)
        {
            filteredConsumables = consumables.Where(c => c.CategoryId == id).ToList();
            var selected = categories.Where(c => c.Id == id).FirstOrDefault();
            if (selected is not null)
                selectedCategory = selected;
            else
                selectedCategory.Id = 0;    

        }
        else
            filteredConsumables = consumables ; // .GetRange(0, consumables.Count); // no filter, copy all or it can be the same list

        // selection changes -> reinitialise editable fields 
        if (consumable is not null)
        {
            consumable.Id = 0;
            consumable.CategoryId = 0;
            consumable.ValueFormat = string.Empty;
            consumable.Design = string.Empty;
            consumable.MeasureUnit = string.Empty;
            consumable.Name = string.Empty;
            consumable.Type = string.Empty;
        }
        else
        {
            consumable = new();    
        }


    }


    protected override async Task OnInitializedAsync()
    {
        AppMenu.SetPageTitle("Tipuri de consumabile");

        await categoryService.LoadConsumableCategoriesAsync();  
        categories = categoryService.Categories;

        await consumableService.LoadConsumablesAsync();
        consumables = consumableService.Types;

        if (consumables.Count >0)
            CategorySelected(0);  // select first 

        if (_table!.GetFilteredItemsCount() == 0)
            crudObj!.EnableActionsBtn();
    }

    private int GetTableItems()
    {
        if (consumable is null || consumable.Id == 0 || _table is null)
            return 0;  // no selection
        return _table.GetFilteredItemsCount();
    }


    protected void RowClicked(TableRowClickEventArgs<Consumable> clickedCategory)
    {
        crudObj!.EnableActionsBtn();
        crudObj!.RowClicked(_table!);
        SelectCurrentItem(clickedCategory.Item.Id);
    }

    private async Task ValidateAction()
    {
        if (crudObj is null)    // ? Not defined ?
            return;
        if (selectedCategory.Id == 0 && crudObj.CurrentAction == ActionState.Add)
        {
            snackBar.Add("Nu este selectata o categorie", Severity.Error);  // nu ar trebui sa ajunga pe aici, dar nu poate salva fara o categorie
            crudObj.CurrentAction = ActionState.Read;
            return;
        }
        consumable.CategoryId = selectedCategory.Id;

        switch (crudObj.CurrentAction)
        {
            case ActionState.Read:
                return;
            case ActionState.Add:
                consumable.Id = 0;
                await consumableService.AddConsumable(consumable);
                snackBar.Add("Inregistrare adaugata", Severity.Success);
                break;
            case ActionState.Edit:
                await consumableService.UpdateConsumable(consumable);
                snackBar.Add("Inregistrare modificata", Severity.Success);
                break;
            case ActionState.Delete:
                if (consumable.Id == 0)
                    return;
                await consumableService.DeleteConsumable(consumable.Id);
                snackBar.Add("Inregistrare stearsa", Severity.Success);
                consumable.Id = 0; 
                break;
        }

        consumables = consumableService.Types;  // reload items
        CategorySelected(selectedCategory.Id);

        crudObj.Read();

        await Task.Delay(1); // let UI refresh
    }

    // movers
    private string searchString = string.Empty;

    private void SelectCurrentItem(int id)
    {
        if (consumables.Count == 0)
            return;

        var search = filteredConsumables.FirstOrDefault(c => c.Id == id);

        if (search is null)
        {
            Console.WriteLine("Not found");
            search = consumables.FirstOrDefault(c => c.Id == id);
            if (search!.CategoryId != selectedCategory.Id)
            {
                snackBar.Add("Consumabilul cautat se regaseste la alta categorie", Severity.Warning);
                Console.WriteLine("Wrong Category");
            }
            consumable.Id = 0;
        }
        else
        {
            consumable = search;
        }
        
    }

    private bool Search(Consumable consumable)
    {
        if (string.IsNullOrWhiteSpace(searchString)) return true;

        if (consumable.Name.Contains(searchString, StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }
        return false;
    }

}
